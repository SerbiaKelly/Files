---
--- Generated by liurenhai
--- Created by liurenhai.
--- DateTime: 2019/5/22 17:07
---
local json = require 'json'

dtz_Logic = {}
local this = dtz_Logic;

local gapLength = 2;--主牌跟带牌的间距

this.DAN       = 0;--单牌
this.DUI       = 1;--对子
this.SAN       = 2;--三张
this.LIAN_DUI  = 3;--连对
this.FEI       = 4;--飞机
this.ZHA_DAN   = 5;--炸弹
this.TONG      = 6;--筒子
this.DI_ZHA    = 7;--地炸
this.XI        = 8;--喜

--提示顺序
local TipOrder = {};
TipOrder[this.DAN]      = 0;
TipOrder[this.DUI]      = 4;
TipOrder[this.SAN]      = 2;
TipOrder[this.LIAN_DUI] = 3;
TipOrder[this.FEI]      = 1;
TipOrder[this.ZHA_DAN]  = 5;
TipOrder[this.TONG]     = 6;
TipOrder[this.DI_ZHA]   = 7;
TipOrder[this.XI]       = 8;





local DiBombDB          = {};
local XiDB              = {};
local TongZiDB          = {};
local BombDB            = {};
local TribleDB          = {};
local PairDB            = {};
local SingleDB          = {};
local CardsDB           = {};
local PlaneDB           = {};
local ContinuesPairDB   = {};


--columnLimit UIGrid的换行条件
--cutLimit  多少张牌需要平均分配
--mainCards 主牌
--slaveCards 带的牌
--posIndex 用来决定是左对齐还是右对齐还是居中
function this.GetOutGridLayOut(columnLimit, cutLimit, mainCards, slaveCards,posIndex)
    --print("GetOutGridLayOut was called,posIndex:"..tostring(posIndex));
    local layoutData            = {};
    layoutData.hideIndexs       = {};--隐藏牌的索引
    layoutData.withCardsIndexs  = {};--带牌的索引
    layoutData.outCardIndex     = {};--出牌的索引
    local cardLength            = #mainCards;
    local withCardLength        = #slaveCards;
    print("cardLength="..cardLength);
    print("withCardLength="..withCardLength);
    --1.普通的出牌
    if withCardLength <= 0 then

        if cardLength < columnLimit then--一排足够
            print("path---------------->1");
            --1.1处理隐藏部分
            local remainCard = columnLimit - cardLength;
            --第一行肯定是隐藏（从下往上数）
            for i = 1, columnLimit do
                table.insert(layoutData.hideIndexs,i);
            end
            local head = math.floor(remainCard/2);--得给个默认值
            local tail = remainCard - head;

            if posIndex == 1 or posIndex == 2 then--右对齐
                tail = 0;
                head = remainCard;
            elseif posIndex ==3 then--左对齐
                head = 0;
                tail = remainCard;
            elseif posIndex == 0 then--居中
                head = math.floor(remainCard/2);
                tail = remainCard - head;
            end
            --第二行隐藏首尾
            --首
            for i = columnLimit+1, columnLimit+head do
                table.insert(layoutData.hideIndexs,i);
            end
            --尾
            for i = columnLimit*2, columnLimit*2 - tail+1,-1 do
                table.insert(layoutData.hideIndexs,i);
            end

            --牌
            for i = columnLimit+head+1, columnLimit*2 - tail do
                table.insert(layoutData.outCardIndex,i);
            end
        else--一排排不下
            print("path---------------->2");
            local remainCard = columnLimit * 2 - cardLength;
            if remainCard < 4 then--小于4张牌，两行不便于居中处理，直接放在最后面吧
                for i = columnLimit, columnLimit - remainCard +1, -1 do
                    table.insert(layoutData.hideIndexs,i);
                end

                for i = columnLimit+1, 2*columnLimit do
                    table.insert(layoutData.outCardIndex,i);
                end

                for i = 1, columnLimit - remainCard do
                    table.insert(layoutData.outCardIndex,i);
                end
                print("path---------------->3");
            else
                local cutFactor = math.floor(remainCard/4);--给个默认值，居中对齐
                local restCard  = remainCard - cutFactor * 4;
                local head      = cutFactor;
                local tail      = cutFactor;
                print("posIndex="..posIndex);
                if posIndex == 1 or posIndex == 2 then--右对齐
                    head = cutFactor*2;
                    tail = 0;
                elseif posIndex ==3 then--左对齐
                    head = 0;
                    tail = cutFactor*2;
                elseif posIndex == 0 then--居中
                    head = cutFactor;
                    tail = tail;
                end

                --隐藏的牌
                for i = columnLimit + 1, columnLimit + head do
                    table.insert(layoutData.hideIndexs,i);
                end
                for i = columnLimit*2, columnLimit * 2 - tail + 1,-1 do
                    table.insert(layoutData.hideIndexs,i);
                end
                for i = 1, head do
                    table.insert(layoutData.hideIndexs,i);
                end
                for i = columnLimit, columnLimit - (tail+restCard)+1,-1 do
                    table.insert(layoutData.hideIndexs,i);
                end
                --要出的牌
                for i = columnLimit + head +1, columnLimit * 2 - tail do
                    table.insert(layoutData.outCardIndex,i);
                end

                for i=head+1,head+cardLength-#layoutData.outCardIndex do
                    table.insert(layoutData.outCardIndex,i);
                end

                print("path---------------->4");
            end
        end
    else--2.飞机带牌
        if cardLength < cutLimit then--只要一行就可以显示
            local remainCard = columnLimit - (withCardLength + cardLength + gapLength);--默认值，居中对齐
            local head = math.ceil(remainCard /2);
            local tail = remainCard - head;


            if posIndex == 1 or posIndex == 2 then--右对齐
                tail = 0;
                head = remainCard;
            elseif posIndex ==3 then--左对齐
                head = 0;
                tail = remainCard;
            elseif posIndex == 0 then--居中
                head = math.ceil(remainCard /2);
                tail = remainCard - head;
            end
            --要隐藏的牌
            for i = 1, columnLimit do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit + 1, columnLimit + head  do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit*2, columnLimit*2 - tail +1,-1 do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit + head + cardLength + 1, columnLimit + head + cardLength + gapLength do
                table.insert(layoutData.hideIndexs,i);
            end

            --要出的牌
            for i = columnLimit + head + 1, columnLimit + head + cardLength do
                table.insert(layoutData.outCardIndex,i);
            end
            --要带的牌
            for i = columnLimit*2 - tail, columnLimit*2 -(tail + withCardLength) + 1,-1 do
                table.insert(layoutData.withCardsIndexs,i);
            end
        else
            local outCardFactor     = math.ceil(cardLength/2); --个一些默认值，是中间对齐
            local withCardFactor    = math.ceil(withCardLength/2);
            local cutFactor         = math.floor((columnLimit- outCardFactor -withCardFactor -gapLength)*2/4);
            local restCard          = (columnLimit- (outCardFactor + withCardFactor + gapLength))*2 - cutFactor * 4;
            local head              = cutFactor;
            local tail              = cutFactor;

            if posIndex == 1 or posIndex == 2 then--右对齐
                head = cutFactor*2;
                tail = 0;
            elseif posIndex == 3 then--左对齐
                head = 0;
                tail = cutFactor*2;
            elseif posIndex == 0 then--居中
                head = cutFactor;
                tail = tail;
            end

            --要隐藏的牌
            for i = columnLimit + 1, columnLimit + head do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit + head + outCardFactor + 1, columnLimit + head + outCardFactor + gapLength do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit * 2, columnLimit * 2 -(tail+restCard/2) + 1,-1 do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = 1, head do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = head+(cardLength-outCardFactor) + 1, head + outCardFactor + gapLength do
                table.insert(layoutData.hideIndexs,i);
            end
            for i = columnLimit * 2, columnLimit * 2 - (tail + restCard/2 + (withCardFactor*2-withCardLength)),-1 do
                table.insert(layoutData.hideIndexs,i);
            end

            --要出的牌
            for i = columnLimit + head+1, columnLimit + head + outCardFactor do
                table.insert(layoutData.outCardIndex,i);
            end
            for i = head+1, head + (cardLength - outCardFactor) do
                table.insert(layoutData.outCardIndex,i);
            end
            --带的牌
            for i = columnLimit + head + outCardFactor +gapLength+1, columnLimit + head + outCardFactor + gapLength + withCardFactor do
                table.insert(layoutData.withCardsIndexs,i);
            end
            for i = head + outCardFactor + gapLength +1, head + outCardFactor + gapLength + (withCardLength-withCardFactor) do
                table.insert(layoutData.withCardsIndexs,i);
            end
        end
    end

    return layoutData;
end

function this.BindIDs(afterPresseDcards)
    for i = 1, #afterPresseDcards do
        afterPresseDcards[i].db_id = i;
    end
end

--初始化数据库
--afterPresseDcards手牌
--cardCount 几副牌的玩法
--needCombination 是否需要重新对牌排序
--是否可以带牌
function this.InitDB(afterPresseDcards,args)

    DiBombDB    = {};
    XiDB        = {};
    TongZiDB    = {};
    BombDB      = {};
    TribleDB    = {};
    PairDB      = {};
    SingleDB    = {};

    this.SetSanOrder(args.isWithPlate);

    table.sort(afterPresseDcards,function (a,b) return a.trueValue < b.trueValue; end);

    this.BindIDs(afterPresseDcards);
    CardsDB = afterPresseDcards;
    local restTable = {};

    if args.cardCount == 3 then--3副牌
        DiBombDB        = this.SuckAllDiBombs(afterPresseDcards);
    else--4副牌
        XiDB            = this.SuckAllXi(afterPresseDcards);
    end

    restTable                       = this.GetRestTable(afterPresseDcards,DiBombDB,this.DI_ZHA);
    restTable                       = this.GetRestTable(restTable,XiDB,this.XI);

    TongZiDB                        = this.SuckAllTongZi(restTable);
    restTable                       = this.GetRestTable(restTable,TongZiDB,this.TONG);

    BombDB                          = this.SuckAllBombs(restTable);
    restTable                       = this.GetRestTable(restTable,BombDB,this.ZHA_DAN);

    PlaneDB                         = this.SuckAllPlanes(restTable,3,args.cardCount==4);

    TribleDB                        = this.SuckAllTrible(restTable);
    restTable                       = this.GetRestTable(restTable, TribleDB,this.SAN);

    ContinuesPairDB                 = this.SuckAllContinuePairs(restTable,2,args.cardCount==4);

    PairDB                          = this.SuckAllPair(restTable);
    restTable                       = this.GetRestTable(restTable, PairDB,this.DUI);

    SingleDB                        = this.SuckAllSingle(restTable);

    CardsDB                         = this.CardsDBReBombine(afterPresseDcards);
    if args.needCombination then
        return CardsDB;
    else
        return this.NomalSort(CardsDB);
        --return afterPresseDcards;
    end
end

--
function this.GetCardsDB()
    return CardsDB;
end


--牌的数据库重组
function this.CardsDBReBombine(originCards)
    if not originCards then
        return {};
    end
    local newCardsDB    = {};
    if #SingleDB > 0 then
        for i = 1, #SingleDB do
            for j = 1, #SingleDB[i] do
                table.insert(newCardsDB, SingleDB[i][j]);
                --print("have pair:"..SingleDB[i][j].value);
                --print("------------------");
            end
        end
    end
    --print("#SingleDB:"..#SingleDB);
    if #PairDB > 0 then
        for i = 1, #PairDB do
            for j = 1, #PairDB[i] do
                table.insert(newCardsDB, PairDB[i][j]);

            end
        end
    end
    --print("#PairDB:"..#PairDB);
    if #TribleDB > 0 then
        for i = 1, #TribleDB do
            for j = 1, #TribleDB[i] do
                table.insert(newCardsDB, TribleDB[i][j]);
            end
        end
    end
    --print("#TribleDB:"..#TribleDB);
    if #BombDB > 0 then
        for i = 1, #BombDB do
            for j = 1, #BombDB[i] do
                table.insert(newCardsDB,BombDB[i][j]);
            end
        end
    end
    if #TongZiDB > 0 then
        for i = 1, #TongZiDB do
            for j = 1, #TongZiDB[i] do
                TongZiDB[i][j].isTongzi = true;
                table.insert(newCardsDB,TongZiDB[i][j]);
            end
        end
    end
    if #XiDB > 0 then
        for i = 1, #XiDB do
            for j = 1, #XiDB[i] do
                XiDB[i][j].isXi = true;
                table.insert(newCardsDB,XiDB[i][j]);
            end
        end
    end
    if #DiBombDB > 0 then
        for i = 1, #DiBombDB do
            for j = 1, #DiBombDB[i] do
                DiBombDB[i][j].isDiBomb = true;
                table.insert(newCardsDB,DiBombDB[i][j]);
            end
        end
    end

    print("newCardsDB.length:"..tostring(#newCardsDB));
    return newCardsDB;
end


function this.NomalSort(originCards)

    table.sort(originCards,function (a,b)

        if a.value > b.value then
            return false;
        elseif a.value < b.value then
            return true;
        else
           if a.isTongzi then
                --print("a.isTongzi:"..tostring(a.isTongzi))
                if b.isXi or b.isDiBomb then
                    return true;
                elseif b.isTongzi then
                    return a.type < b.type;
                else
                    return false;
                end

           elseif a.isDiBomb then

                   if b.isDiBomb then
                       return a.type < b.type;
                   else
                       return false;
                   end
            elseif a.isXi then
                if b.isDiBomb then
                    return true;
                elseif b.isXi then
                    return a.type < b.type;
                else
                    return false;
                end
            else
                if b.isXi or b.isDiBomb or b.isTongzi then
                    return true;
                else
                    return a.type < b.type;
                end
            end
        end
    end);

    --for i = 1, #originCards do
    --    print("item :"..i.." value:"..originCards[i].value.."|type:"..this.getTypeString(originCards[i].type).."|isDiBomb:"..tostring(originCards[i].isDiBomb).."|isXi:"..tostring(originCards[i].isXi));
    --end

    return originCards;

end

--function this.getTypeString(type)
--    if type == 0 then
--        return "方块";
--    elseif type == 1 then
--        return "梅花"
--    elseif type == 2 then
--        return "红桃";
--    elseif type == 3 then
--        return "黑桃";
--    end
--end




function this.GetOffCut()
    local restTable = this.GetRestTable(CardsDB,DiBombDB);
    restTable = this.GetRestTable(restTable,XiDB);
    restTable = this.GetRestTable(restTable,TongZiDB);
    restTable = this.GetRestTable(restTable,BombDB);
    return restTable;
end


--排除某个table中的所有元素，获得剩下的
function this.TableExcept(originTalbe,exceptTable,category)
    if not originTalbe or not exceptTable then
        return {};
    end
    local restTable = {};
    if category == this.LIAN_DUI or category == this.FEI then
        for i = 1, #originTalbe do
            if not this.IsFindInTable(exceptTable.value,originTalbe[i],"db_id") then
                table.insert(restTable,originTalbe[i]);
            end
        end
    else
        for i = 1, #originTalbe do
            if not this.IsFindInTable(exceptTable,originTalbe[i],"db_id") then
                table.insert(restTable,originTalbe[i]);
            end
        end
    end
    return restTable;
end

function this.GetRestTable(afterPresseDcards,db,category)
    local restTable = afterPresseDcards;

    for i = 1, #db do
         restTable = this.TableExcept(restTable,db[i],category);
    end
    return restTable;
end


--一张牌是大王还是否是大小王
function this.IsJocker(cardInfo)
    if cardInfo.value == 16 or cardInfo.value == 17 then
        return true;
    end
    return false;
end


--是否是大王
function this.IsRedJocker(cardInfo)
    return cardInfo.value == 17
end

--是否是小王
function this.IsGrayJocker(cardInfo)
    return cardInfo.value == 16;
end

--设置深度
function this.SetSpriteDepth(_Sprite,depth)
    _Sprite.depth = depth;
end

this.ByValue        = 0;
this.ByTrueValue    = 1;
this.ByType         = 2;
this.JudgeByTongzi  = 0;
this.JudgeByXi      = 1;

function this.TypeCompare(value1,value2,compareType)
    if compareType == this.ByValue then
        return value1.value == value2.value;
    end

    if compareType == this.ByTrueValue then
        return value1.trueValue == value2.trueValue;
    end

    if compareType == this.ByType then
        return value1.type == value2.type;
    end

    return false;
end


--查找某个值是否在table中
function this.IsFindInTable(findTable,value,key)
    if not findTable or not value then
        return false;
    end
    for i = 1, #findTable do
        local data1 = key and findTable[i][key] or findTable[i];
        local data2 = key and value[key] or value;
        if data1 == data2 then
            return true;
        end
    end
    return false;
end


--获得牌的统计(通过牌面值)
-- Value,TrueValue,Type
--afterPresseDcards经过处理后的牌，包含真实值，牌面值，和牌类型
function this.GetCardCountByType(afterPresseDcards, type)
    local countTable = {};
    if not afterPresseDcards then
        return ;
    end
    function getIndexByType(cardItem,type)
        if type == this.ByValue then
            return cardItem.value;
        elseif type == this.ByTrueValue then
            return cardItem.trueValue;
        elseif type == this.ByType then
            return cardItem.type;
        end
    end
    for i = 1, #afterPresseDcards do
        if not countTable[getIndexByType(afterPresseDcards[i],type)] then
            countTable[getIndexByType(afterPresseDcards[i],type)] = {};
        end
        table.insert(countTable[getIndexByType(afterPresseDcards[i],type)],afterPresseDcards[i]);
    end

    return countTable;
end

--将主牌跟带牌分开
--afterPresseDcards经过处理后的牌，包含真实值，牌面值，和牌类型
function this.SeperateMainAndSlave(afterPresseDcards, category,cardCount,keyCardCount)
    if not afterPresseDcards then
        return nil;
    end
    if category < this.DAN or category > this.XI then
        print("invalid category :"..tostring(category));
        return;
    end
    local main  ={};
    local slave ={};
    --1.没有带牌的情况
    if (category == this.DAN or
            category == this.DUI or
            category == this.LIAN_DUI or
            category == this.ZHA_DAN or
            category == this.TONG or
            category == this.DI_ZHA or
            category == this.XI )
    then
        main    = afterPresseDcards;

        --按从小到大排序
        table.sort(main,function (a,b) return a.value < b.value end);
        slave   = {};
        --2.有带牌的情况
    else
        --2.1如果是三张带牌
        if category == this.SAN  then
            local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);
            for key, value in pairs(countTable) do
                if #value == 3 then
                    for j = 1, #value do
                        table.insert(main,value[j]);
                    end
                elseif #value > 3 then
                    for i = 1, 3 do
                        table.insert(main,value[i]);
                    end
                    for j = 4, #value do
                        table.insert(slave,value[j]);
                    end
                else
                    for j = 1, #value do
                        table.insert(slave,value[j]);
                    end
                end
            end
            --2.2飞机带牌
        elseif category == this.FEI then
            local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);
            for key, value in pairs(countTable) do
                if #value == 3 then
                    for j = 1, #value do
                        table.insert(main,value[j]);
                    end
                elseif #value > 3 then
                    for i = 1, 3 do
                        table.insert(main,value[i]);
                    end
                    for j = 4, #value do
                        table.insert(slave,value[j]);
                    end
                else
                    for j = 1, #value do
                        table.insert(slave,value[j]);
                    end
                end
            end

            --因为飞机是连续的两个或者以上三张相同的牌
            --判断是否连续
            table.sort(main,function (a,b) return a.value < b.value; end);
            local breakData     = this.GetCountinusBreakData(main,3,1,"value");
            local afterMain     = {};
            local afterSlave    = {};

            --飞机主体
            --stepTotal最大的那个就是飞机，而剩余的就是带的牌
            table.sort(breakData,function (a,b) return a.stepTotal > b.stepTotal end);
            for j = breakData[1].startPos, breakData[1].endPos+2 do
                --三副牌连对和飞机不包括大小王
                if cardCount == 3 or cardCount == 5 then
                    if this.IsJocker(main[j]) or main[j].value == 15 then
                        table.insert(afterSlave,main[j]);
                    else
                        table.insert(afterMain,main[j]);
                    end
                else
                    table.insert(afterMain,main[j]);
                end

            end

            local newAfterMain = {};
            for i = #afterMain, (#afterMain - keyCardCount*3+1),-1 do
                table.insert(newAfterMain,afterMain[i]);
            end

            for i = 1, #afterMain - keyCardCount*3 do
                table.insert(afterSlave,afterMain[i]);
            end

            --带的牌
            for i = 2, #breakData do
                for k = breakData[i].startPos, breakData[i].endPos+2 do
                    table.insert(afterSlave,main[k]);
                end
            end
            for i = 1, #slave do
                table.insert(afterSlave,slave[i]);
            end
            main    = newAfterMain;
            slave   = afterSlave;
        end
    end

    if category == this.DI_ZHA then
        table.sort(main,function (a,b) return a.type > b.type; end);
    else
        table.sort(main,function (a,b) return a.value < b.value; end);
    end
    table.sort(slave,function (a,b) return a.value < b.value; end);
    return main,slave;
end

--获取连续值的断裂位置信息，
--datas 原始数据，是一个数组,在步进内，必须要一样的数据比如[22,33,44,55,66],[111,222,333,444,777,888],[1,2,3,4,6,7]等
--step 步进，比如两个数为一步，三个数为一步
--gap 作为连续值的误差，比如 gap=1，那么1，2，3，4，5是连续的，如果gap=-1,那么0，-1，-2，-3，-4是连续的，gap=2，那么2，4，6，8，10是连续的
--key 数据里面的某个key
function this.GetCountinusBreakData(datas,step,gap,key)
    if not datas then
        return nil ;
    end
    local breakData     = {};
    local startPos      = 1;
    local endPos        = 1;
    local stepTotal     = 1;
    local index         = endPos+step;
    for i = index, #datas,step do

        local compareData1 = key and datas[i][key] or datas[i];
        local compareData2 = key and datas[i-step][key] or datas[i-step];

        if compareData1 - compareData2 == gap then
            stepTotal   = stepTotal + 1;
            endPos      = i;
        else
            local breakItem     = {};
            breakItem.startPos  = startPos;
            breakItem.endPos    = endPos;
            breakItem.stepTotal = stepTotal;
            table.insert(breakData,breakItem);
            startPos    = i;
            endPos      = i;
            stepTotal   = 1;
        end

    end
    --最后一个元素比较特殊，可能跳出了循环，但是数据没有保存到breakData中
    local breakItem = {};
    breakItem.startPos  = startPos;
    breakItem.endPos    = endPos;
    breakItem.stepTotal = stepTotal;
    table.insert(breakData,breakItem);
    return breakData;
end


--获得所有包含"对"的元素
--pairNum "对"的个数，如2[最少为2]个,[22,33,44,55],3个[222,333,444,555]
function this.GetContinusPairData(afterPresseDcards, pairNum)
    if not afterPresseDcards or pairNum < 2 then
        return nil;
    end

    --print("GetContinusPairData-----------------> #afterPresseDcards:"..#afterPresseDcards.."|pairNum:"..pairNum);

    table.sort(afterPresseDcards,function (a,b) return a.value < b.value end);

    local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);

    --筛选出能拿出对子的组合
    local originContinuePair = {};
    for key, value in pairs(countTable) do
        if #value >=pairNum then
            table.insert(originContinuePair,value);
        end
    end

    table.sort(originContinuePair,function (a,b) return a[1].value < b[1].value end);

    --选出所有的对子
    local pairStartPos  = 1;
    local pairEndPos    = 1;
    local index         = 2;
    local pairLength    = 1;
    local PairDataTable = {};
    local tempContinus  = {};
    table.insert(tempContinus,originContinuePair[1]);
    for i = index, #originContinuePair do

        if originContinuePair[i][1].value - originContinuePair[i-1][1].value == 1 then
            --print("fund coutinus,insert value is:"..originContinuePair[i][1].value);
            pairEndPos = i;
            pairLength = pairLength + 1;
        else
            pairStartPos            = i;
            local pairDataItem      = {};
            pairDataItem.pairLength = pairLength;
            pairDataItem.continus   = {};
            for j = 1, #tempContinus do
                table.insert(pairDataItem.continus,tempContinus[j]);
            end
            tempContinus            = {};
            pairLength              = 1;
            table.insert(PairDataTable,pairDataItem);
        end
        table.insert(tempContinus,originContinuePair[i]);
    end
    --最后一个元素需要特殊处理
    local pairDataItem      = {};
    pairDataItem.pairLength = pairLength;
    pairDataItem.continus   = {};
    for j = 1, #tempContinus do
        table.insert(pairDataItem.continus,tempContinus[j]);
    end
    table.insert(PairDataTable,pairDataItem);

    return PairDataTable;

end


--获得可行的单张
function this.GetViableSingle(card)

    --获取所有不为单牌的数据
    local countTable    = this.GetCardCountByType(this.GetOffCut(),this.ByValue);
    local findAll       = (card == nil) and true or false;
    --剩余的单牌
    local singleCards = {};
    for key, value in pairs(countTable) do
        --首先不拆其他牌，玩家拥有的单牌
        if #value == 1 then
            table.insert(singleCards,value[1]);
            --拆其他牌，玩家拥有的单牌
        elseif (not findAll) and #value > 1  and value[1].value > this.GetMaxSingleValueData()  then
            if value[1].value > card.value and #value <=3  then
                if not this.IsTongZiOrXi(value,this.JudgeByTongzi) then
                    table.insert(singleCards,value[1]);
                end
            end
        end
    end
    --

    local realsingleCards = {};

    if findAll then
        realsingleCards = singleCards;
    else
        for i = 1, #singleCards do
            if singleCards[i].value > card.value then
                table.insert(realsingleCards,singleCards[i]);
            end
        end
    end
    --由小到大排序
    table.sort(realsingleCards,function (a,b) return a.value < b.value; end);
    return realsingleCards;
end

function this.generatePair(value,pairBreak)
    local endIndex = math.floor(#value/2)*2;
    local tempViablePiars = {};
    table.sort(value,function (a,b) return a.type > b.type; end);
    for i = 1, endIndex,2 do
        local pairItem = {};
        pairItem.breakOP = pairBreak;
        pairItem.value = {};
        local j = i;
        for j = i, j+1 do
            table.insert(pairItem.value,value[j]);
        end
        table.insert(tempViablePiars,pairItem);
    end

    return tempViablePiars;
end

--获得可行的对子
function this.GetViablePair(cards)
    local findAll = (cards == nil or #cards == 0 ) and true or false;
    local viablePiars = {};
    local countTable = this.GetCardCountByType(this.GetOffCut(),this.ByValue);
    for key, value in pairs(countTable) do
        --获得只有两张的对子 就是说，这是一个纯粹的对子[不是从其他三张或者炸弹中拆出来的对子]，一个脱离了低级趣味的栗子，一个为人民服务的对子
        if  #value == 2 then
            local tempViablePiars = this.generatePair(value,-1);
            for i = 1, #tempViablePiars do
                table.insert(viablePiars,tempViablePiars[i]);
            end
            --获得从其他牌中拆出来的对子,只要比最大的单张还要大的对子
        elseif  not findAll and #value > 2 and value[1].value > this.GetMaxPairValueData()  then
            if this.IsSanZhang(value) then
                local tempViablePiars = this.generatePair(value,this.SAN);
                for i = 1, #tempViablePiars do
                    table.insert(viablePiars,tempViablePiars[i]);
                end
            end
        end
    end

    --是否要找所有
    local realViablePair = {};
    if findAll then
        realViablePair = viablePiars;
    else
        for i = 1, #viablePiars do
            if viablePiars[i].value[1].value > cards[1].value then
                table.insert(realViablePair,viablePiars[i]);
            end
        end
    end
    --由小到大排序
    table.sort(realViablePair,function (a,b) return a.value[1].value < b.value[1].value;  end);
    return realViablePair;

end




--判断是否是炸弹
function this.IsBomb(afterPresseDcards)
    local isBomb = true;
    if not afterPresseDcards then
        isBomb = false;
    end
    if #afterPresseDcards < 4 then
        isBomb = false;
    end
    for i = 2, #afterPresseDcards do
        if not this.TypeCompare(afterPresseDcards[1],afterPresseDcards[i],this.ByValue) then
            isBomb = false;
            break;
        end
    end
    return isBomb;
end

--判断是否是筒子或者喜
function this.IsTongZiOrXi(afterPresseDcards,tongzi)
    local isTongzi = true;
    if not afterPresseDcards then
        isTongzi = false;
    end
    local campareLength = tongzi == this.JudgeByTongzi and 3 or 4;
    if #afterPresseDcards < campareLength then
        isTongzi = false;
    end

    if #afterPresseDcards == campareLength then

        for i = 2, #afterPresseDcards do
            if this.TypeCompare(afterPresseDcards[1],afterPresseDcards[i],this.ByType) and this.TypeCompare(afterPresseDcards[1],afterPresseDcards[i],this.ByValue) then
                local m = 100;
            else
                isTongzi = false;
                break;
            end
        end

    else
        isTongzi = false;
    end

    return isTongzi;
end

--判断是否是三张
function this.IsSanZhang(afterPresseDcards)
    if not afterPresseDcards or #afterPresseDcards ~=3 then
        return false;
    end

    if this.IsTongZiOrXi(afterPresseDcards,this.JudgeByTongzi) then
        return false;
    end

    local isSanZhang = true;
    for i = 1, #afterPresseDcards-1 do
        if afterPresseDcards[i].value ~= afterPresseDcards[i+1].value then
            isSanZhang = false;
            break;
        end
    end

    return isSanZhang;

end

--判断是否是三带牌
function this.IsSanDai(afterPresseDcards)
    if #afterPresseDcards < 3 or #afterPresseDcards > 5 then
        return false;
    end

    if this.IsTongZiOrXi(afterPresseDcards,this.JudgeByTongzi) or this.IsTongZiOrXi(afterPresseDcards,this.JudgeByXi) or this.IsBomb(afterPresseDcards) then
        return false;
    end

    local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);

    for key, value in pairs(countTable) do
        if #value == 3 then
            return true;
        end
    end
    return false;
end

--判断是否是地炸
function this.IsDiBomb(afterPresseDcards)
    local isDiBomb = true;
    if not afterPresseDcards then
        isDiBomb = false;
    end
    if #afterPresseDcards < 8 then
        isDiBomb = false;
    end

    if #afterPresseDcards == 8 then
        local countTable = this.GetCardCountByType(afterPresseDcards,this.ByType);
        local typeCount = 0;
        for key, value in pairs(countTable) do
            typeCount = typeCount + 1;
        end

        if typeCount ~= 4 then
            isDiBomb = false;
        else
            for key, value in pairs(countTable) do
                if #value < 2 then
                    isDiBomb = false;
                end
            end
        end
    else
        isDiBomb = false;
    end


    return isDiBomb;



end


function this.generateTrible(value,tribleBreak)
    local endIndex = math.floor(#value/3)*3;
    local tempViableTribles = {};
    for i = 1, endIndex ,3 do
        local tribleItem = {};
        tribleItem.breakOP = tribleBreak;
        tribleItem.value = {};
        local secdex = i ;
        for secdex = i, secdex +2 do
            table.insert(tribleItem.value,value[secdex]);
        end
        table.insert(tempViableTribles,tribleItem);
    end
    return tempViableTribles;
end

--获得可行的三张
function this.GetViableTrible(cards)


    local viableTribles = {};
    local countTable    = this.GetCardCountByType(this.GetOffCut(),this.ByValue);
    local findAll       = (cards == nil or  #cards == 0 ) and true or false;

    for key, value in pairs(countTable) do
        if #value == 3 then--刚好是三张
            if not this.IsTongZiOrXi(value,this.JudgeByTongzi) then--不是筒子才放进去
                local tempViableTribles = this.generateTrible(value,-1);
                for i = 1, #tempViableTribles do
                    table.insert(viableTribles,tempViableTribles[i]);
                end
            end
        end
    end
    --key > cards[1].value and
    local realViableTribles = {};
    if findAll then
        realViableTribles = viableTribles;
    else
        for i = 1, #viableTribles do
            if viableTribles[i].value[1].value > cards[1].value then
                table.insert(realViableTribles,viableTribles[i]);
            end
        end
    end
    table.sort(realViableTribles,function (a,b) return a.value[1].value < b.value[1].value; end);
    return realViableTribles;
end

function this.GetViableContinuesPair(cards)
    local needViableContinuesPairs = {};

    local findAll = (cards == nil or #cards == 0 ) and true or false;
    if findAll then
        return ContinuesPairDB;
    end

    table.sort(cards,function (a,b) return a.value < b.value; end);
    for i = 1, #ContinuesPairDB do
        local continusLength = #ContinuesPairDB[i].value;
        local cardLength = #cards;
        if ContinuesPairDB[i].value[continusLength].value > cards[cardLength].value then
            table.insert(needViableContinuesPairs,ContinuesPairDB[i]);
        else
            --print("the value was smaller than competitor ,value:"..viableContinuesPairs[i].value[continusLength].value);
        end
    end

    table.sort(needViableContinuesPairs,function (a, b) return a.value[1].value < b.value[1].value; end);
    return needViableContinuesPairs;
end




function this.GetViablePlane(cards)
   local needViablePlanes = {};
    local findAll = (cards == nil or #cards == 0 ) and true or false;

    if findAll then
        return PlaneDB;
    end

    table.sort(cards,function (a,b) return a.value < b.value; end);

    for i = 1, #PlaneDB do
        local planeLength = #PlaneDB[i].value;
        local cardLength = #cards;
        if PlaneDB[i].value[planeLength].value > cards[cardLength].value then
            table.insert(needViablePlanes,PlaneDB[i]);
        end
    end

    table.sort(needViablePlanes,function (a,b) return a.value[1].value < b.value[1].value ;end);
    return needViablePlanes;
end


--获得可行的连"对"
--pairNum 对子的数量 如果pairNum = 2 那么获得[22,33,44,55,66] 如果pairNum = 3 那么获得[222,333,444,555,666]
--isInclude_2_or_Jocker 是否包括大小王跟飞机
function this.GetViableContinuesPairAll(cards,pairNum,isInclude_2_or_Jocker ,isNeedOffCut)


    if isInclude_2_or_Jocker == nil then
        isInclude_2_or_Jocker = true;
    end

    local ContinuesPairData;
    if isNeedOffCut then
        ContinuesPairData = this.GetContinusPairData(this.GetOffCut(),pairNum);
    else
        ContinuesPairData = this.GetContinusPairData(CardsDB,pairNum);
    end

    --获得含有连对的数据
    local findAll = (cards == nil or #cards == 0 ) and true or false;
    if not findAll then
        table.sort(cards,function (a,b) return a.value < b.value end);
    end

    --print("isInclude_2_or_Jocker------->"..tostring(isInclude_2_or_Jocker));

    --删掉不包括的连对
    this.Remove2AndJocker(ContinuesPairData,isInclude_2_or_Jocker);
    local viableContinuesPairs = {};
    for i = 1, #ContinuesPairData do

        local pairLength = (cards == nil or #cards==0) and (ContinuesPairData[i].pairLength >= 2 and ContinuesPairData[i].pairLength or 2) or #cards/pairNum; --如果传进来的cards是空，那么最小为2连对
        local cardLength = (cards == nil or #cards==0) and 2*pairNum or #cards;
        --这里选最大的连队,
        --print("pairLength:"..pairLength);
        if ContinuesPairData[i].pairLength >= pairLength  then
            local subContinuesPairs = this.GetSeperateSubContinues(ContinuesPairData[i],cards,pairNum);
            for i = 1, #subContinuesPairs do
                local PairItem      = {};
                PairItem.breakOP    = {};
                PairItem.value      = {};
                table.insert(PairItem.breakOP,-1);
                for j = 1, #subContinuesPairs[i] do
                    table.insert(PairItem.value,subContinuesPairs[i][j]);
                end
                if #PairItem.value > 0 then
                    table.insert(viableContinuesPairs,PairItem);
                end
            end

        end
    end

    --print("PairNum:"..pairNum);
    --print("viableContinuesPairs:"..#viableContinuesPairs);

    local realViableContinuesPairs = {};
    if findAll then
        realViableContinuesPairs = viableContinuesPairs;
    else
        for i = 1, #viableContinuesPairs do
            table.sort(viableContinuesPairs[i].value,function (a,b) return a.value<b.value end);
        end

        for i = 1, #viableContinuesPairs do
            local continusLength = #viableContinuesPairs[i].value;
            local cardLength = #cards;
            if viableContinuesPairs[i].value[continusLength].value > cards[cardLength].value then
                table.insert(realViableContinuesPairs,viableContinuesPairs[i]);
            else
                --print("the value was smaller than competitor ,value:"..viableContinuesPairs[i].value[continusLength].value);
            end
        end
    end

    table.sort(realViableContinuesPairs,function (a,b) return a.value[1].value < b.value[1].value; end);
    return realViableContinuesPairs;

end


--获得满足要求的最小的连对
--continus 自己找出来的满足要求的连对
--cards 对方打过来的连对牌
--pairNum 对子的数量
function this.GetMinContinuePair(ContinueData, cards, pairNum)
    local needContinues = {};

    local pairLength = (cards == nil or #cards==0) and (ContinueData.pairLength >= 2 and ContinueData.pairLength or 2) or #cards/pairNum;
    table.sort(ContinueData.continus,function (a,b) return a[1].value < b[1].value; end);
    if cards then
        table.sort(cards,function (a,b) return a.value < b.value; end);
    end
    local posIndex = -1;

    local processContinus = {};
    for i = 1, #ContinueData.continus do
        for j = 1, pairNum do
            table.insert(processContinus,ContinueData.continus[i][j]);
        end
    end
    if cards and #cards > 0 then
        for i = 1, #processContinus , pairNum do
            if processContinus[i].value > cards[1].value then
                posIndex = i;
                break;
            end
        end
    else
        posIndex = 1;
    end

    if posIndex ~= -1 then
        for i = posIndex, (posIndex + pairLength * pairNum)-1 do
            table.insert(needContinues,processContinus[i]);
        end

    end
    return needContinues;
end

--打一个长的连对中从小到大获取所有满足的连对，比如对方出55，66，如果自己有一个66，77，88，99的连对，那么下面的连对都符合要求，66，77|77，88|88，99都是符合要求的连对，
function this.GetSeperateSubContinues(ContinueData,cards,pairNum)
    local subContinuesPairs = {};
    local pairLength = (cards == nil or #cards==0) and (ContinueData.pairLength >= 2 and ContinueData.pairLength or 2) or #cards/pairNum;
    table.sort(ContinueData.continus,function (a,b) return a[1].value < b[1].value; end);
    if cards then
        table.sort(cards,function (a,b) return a.value < b.value; end);
    end

    --把值放到一个一维table里面
    local posIndex          = -1;
    local processContinus   = {};
    for i = 1, #ContinueData.continus do
        for j = 1, pairNum do
            table.insert(processContinus,ContinueData.continus[i][j]);
        end
    end


    if cards and #cards > 0 then
        for i = 1, #processContinus , pairNum do
            if processContinus[i].value > cards[1].value then
                posIndex = i;
                break;
            end
        end
    else
        posIndex = 1;
    end

    if posIndex ~= -1 then
        for i = posIndex, #processContinus-(pairLength * pairNum)+1,pairNum do
            local continusPairItem = {};
            --print("start at "..i);
            for j = i, (posIndex + pairLength * pairNum)-1 do
                table.insert(continusPairItem,processContinus[j]);
            end
            --print("end at:"..(posIndex + pairLength * pairNum)-1);
            if #continusPairItem >0 then
                table.insert(subContinuesPairs,continusPairItem);
            end
            posIndex = posIndex + pairNum;
        end
    end

    return subContinuesPairs;
end


--移除大小王和2
function this.Remove2AndJocker(ContinuesPairData,isInclude_2_or_Jocker)
    if not isInclude_2_or_Jocker then
        for i = 1, #ContinuesPairData do
            --print("removebefore:pairLength"..ContinuesPairData[i].pairLength);
            for j = #ContinuesPairData[i].continus, 1,-1 do

                if ContinuesPairData[i].continus[j][1].value == 15 or ContinuesPairData[i].continus[j][1].value == 16 or ContinuesPairData[i].continus[j][1].value == 17 then
                    table.remove(ContinuesPairData[i].continus,j);
                    ContinuesPairData[i].pairLength = ContinuesPairData[i].pairLength -1;
                end
            end
            --print("removeafter:pairLength"..ContinuesPairData[i].pairLength);
        end
    end
end

--获得可行的飞机
function this.GetViablePlaneAll(cards,isInclude_2_or_Jocker,isNeedOffCut)

    return this.GetViableContinuesPairAll(cards,3,isInclude_2_or_Jocker,isNeedOffCut);
end

--获得可行的炸弹
function this.GetViableBomb(cards)

    if not cards then
        return {};
    end
    local viableBombs = {};
    for i = 1, #BombDB do
        if #BombDB[i] > #cards then
            table.insert(viableBombs,BombDB[i]);
        elseif #BombDB[i] == #cards then
            if BombDB[i][1].value > cards[1].value then
                table.insert(viableBombs,BombDB[i]);
            end
        end
    end
    --先按炸弹长度排序，长度一样则按照牌面值排序
    table.sort(viableBombs,
            function (a,b)
                if #a < #b then
                    return true;
                elseif #a == #b then
                    return a[1].value < b[1].value;
                else
                    return false;
                end
            end);

    return viableBombs;
end

function this.GetAllBombs()
    table.sort(BombDB,
            function (a,b)
                if #a < #b then
                    return true;
                elseif #a == #b then
                    return a[1].value < b[1].value;
                else
                    return false;
                end
            end);
    return BombDB;
end

--获得可行的筒子
function this.GetViableTongzi(cards,cardCount)
    if not cards then
        return {};
    end

    local viableTongZis = {};
    for i = 1, #TongZiDB do
        if TongZiDB[i][1].value > cards[1].value then
            table.insert(viableTongZis,TongZiDB[i]);
        elseif cardCount ~=4 and TongZiDB[i][1].value == cards[1].value then
            if TongZiDB[i][1].type > cards[1].type then
                table.insert(viableTongZis,TongZiDB[i]);
            end
        end
    end
    table.sort(viableTongZis,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);

    return viableTongZis;
end

function this.GetAllTongzi()
    table.sort(TongZiDB,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);

    return TongZiDB;
end

--获得可行的地炸
function this.GetViableDiBombs(cards)
    if not cards then
        return {};
    end

    local viableDiZha = {};
    for i = 1, #DiBombDB do
        if DiBombDB[i][1].value > cards[1].value then
            table.insert(viableDiZha,DiBombDB[i]);
        end
    end
    table.sort(viableDiZha,function (a,b) return a[1].value < b[1].value; end);
    return viableDiZha;

end


function this.GetAllDiBombs()
    table.sort(DiBombDB,function (a,b) return a[1].value < b[1].value; end);

    return DiBombDB;
end

--从牌中提取地炸（注意这里必须传牌面值一样的数据进来，比如全部都是7）
function this.ExtractDiBombs(cards)
    if not cards or #cards < 8 then
        return nil;
    end

    local countTable = this.GetCardCountByType(cards,this.ByType);
    local typeCount = 0;
    for key, value in pairs(countTable) do
        typeCount = typeCount + 1;
    end
    local extractDiBombs = {};
    if typeCount ~= 4 then--没有黑红梅方肯定不是地炸
        return nil;
    else

        for key, value in pairs(countTable) do
            table.sort(value,function (a,b) return a.db_id < b.db_id; end);
            if #value >=2 then
                for i = 1, 2 do
                    table.insert(extractDiBombs,value[i]);
                end
            end
        end
    end

    if not this.IsDiBomb(extractDiBombs) then
        return nil;
    end
    return extractDiBombs;
end


--获得可行的喜
function this.GetViableXi(cards,cardCount)
    if not cards then
        return {};
    end

    local viableXis = {};
    for i = 1, #XiDB do
        if XiDB[i][1].value > cards[1].value then
            table.insert(viableXis,XiDB[i]);
        elseif cardCount ~= 4 and XiDB[i][1].value == cards[1].value then
            if XiDB[i][1].type > cards[1].type then
                table.insert(viableXis,XiDB[i]);
            end
        end
    end
    table.sort(viableXis,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);
    return viableXis;
end

function this.GetAllXi()
    table.sort(XiDB,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);
    return XiDB;
end


function this.SuckAllPlanes(afterPresseDcards,pairNum,isInclude_2_or_Jocker)
    --print("SuckPlane");
    return this.SuckAllContinuePairs(afterPresseDcards,pairNum,isInclude_2_or_Jocker);
end


function this.SuckAllContinuePairs(afterPresseDcards,pairNum,isInclude_2_or_Jocker)

    --print("#afterPresseDcards in SuckAllContinuePairs:"..#afterPresseDcards);

    if isInclude_2_or_Jocker == nil then
        isInclude_2_or_Jocker = true;
    end

    local ContinuesPairData = this.GetContinusPairData(afterPresseDcards,pairNum);
    local findAll = true


    --print("isInclude_2_or_Jocker------->"..tostring(isInclude_2_or_Jocker));

    --删掉不包括的连对
    this.Remove2AndJocker(ContinuesPairData,isInclude_2_or_Jocker);
    local viableContinuesPairs = {};
    for i = 1, #ContinuesPairData do

        local pairLength = ContinuesPairData[i].pairLength>=2 and  ContinuesPairData[i].pairLength  or 2;
        --这里选最大的连队,
        --print("pairLength:"..pairLength);
        local continusLength = #ContinuesPairData[i].continus;
        local PairItem      = {};
        PairItem.breakOP    = {};
        PairItem.value      = {};
        if ContinuesPairData[i].pairLength >= pairLength then
            for j = #ContinuesPairData[i].continus, continusLength - pairLength+1,-1 do
                table.insert(PairItem.breakOP,-1);
                for k = 1, pairNum do
                    if pairNum == 3 then
                        PairItem.isPlane = true;--标记是飞机
                    elseif pairNum == 2 then
                        PairItem.isContinuePair = true;--标记是连对
                    end
                    table.insert(PairItem.value,ContinuesPairData[i].continus[j][k]);
                    --print("inser value:k"..k.."|value:"..ContinuesPairData[i].continus[j][k].value);
                end
            end
            if #PairItem.value > 0 then
                table.insert(viableContinuesPairs,PairItem);
            end
        end

    end
    --print("PairNum:"..pairNum);
    --print("viableContinuesPairs:"..#viableContinuesPairs);
    return viableContinuesPairs;

end


function this.SuckAllSingle(afterPresseDcards)
    --获取所有不为单牌的数据
    local countTable    = this.GetCardCountByType(afterPresseDcards,this.ByValue);

    --剩余的单牌
    local singleCards = {};

    for key, value in pairs(countTable) do
        --首先不拆其他牌，玩家拥有的单牌
        if #value == 1 then
            table.insert(singleCards,value);
            --拆其他牌，玩家拥有的单牌
        end
    end

    --由小到大排序
    table.sort(singleCards,function (a,b) return a[1].value < b[1].value; end);
    return singleCards;
end

function this.SuckAllPair(afterPresseDcards)

    local viablePiars = {};
    local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);
    for key, value in pairs(countTable) do
        --获得只有两张的对子 就是说，这是一个纯粹的对子[不是从其他三张或者炸弹中拆出来的对子]，一个脱离了低级趣味的栗子，一个为人民服务的对子
        if  #value == 2 then
            table.insert(viablePiars,value);
        end
    end
    --由小到大排序
    table.sort(viablePiars,function (a,b) return a[1].value < b[1].value;  end);
    return viablePiars;
end

function this.SuckAllTrible(afterPresseDcards)
    local viableTribles = {};
    local countTable    = this.GetCardCountByType(afterPresseDcards,this.ByValue);


    for key, value in pairs(countTable) do
        if #value == 3 then--刚好是三张
            if not this.IsTongZiOrXi(value,this.JudgeByTongzi) then--不是筒子才放进去
                table.insert(viableTribles,value);
            end
        end
    end
    table.sort(viableTribles,function (a,b) return a[1].value < b[1].value; end);
    return viableTribles;
end


--获得所有炸弹
function this.SuckAllBombs(afterPresseDcards)
    if not afterPresseDcards then
        return nil;
    end

    local viableAllBombs    = {};
    local countTable        = this.GetCardCountByType(afterPresseDcards,this.ByValue);
    for key, value in pairs(countTable) do
        if this.IsBomb(value) then
            table.insert(viableAllBombs,value);
        end
    end
    table.sort(viableAllBombs,
            function (a,b)
                if #a < #b then
                    return true;
                elseif #a == #b then
                    return a[1].value < b[1].value;
                else
                    return false;
                end
            end);
    return viableAllBombs;
end

--获得所有筒子
function this.SuckAllTongZi(afterPresseDcards)
    if not afterPresseDcards then
        return nil;
    end
    local viableAllTongZi   = {};
    local countTable        = this.GetCardCountByType(afterPresseDcards,this.ByValue);

    for key, value in pairs(countTable) do
        if this.IsTongZiOrXi(value,this.JudgeByTongzi) then
            table.insert(viableAllTongZi,value);
        else
            -- 筒子藏在炸弹里面
            local typeCountTable = this.GetCardCountByType(value,this.ByType);
            for typeKey, typeValue in pairs(typeCountTable) do
                if #typeValue == 3 then
                    table.insert(viableAllTongZi,typeValue);
                end
            end
        end
    end
    table.sort(viableAllTongZi,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);
    return viableAllTongZi;
end

--获得所有地炸
function this.SuckAllDiBombs(afterPresseDcards)
    if not afterPresseDcards then
        return nil;
    end

    local viableAllDiBombs = {};
    local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);
    for key, value in pairs(countTable) do
        if this.IsDiBomb(value) then
            table.insert(viableAllDiBombs,value);
        elseif #value > 8 then
            local extractDiBombs = this.ExtractDiBombs(value);
            if extractDiBombs ~= nil then
                table.insert(viableAllDiBombs,extractDiBombs);
            end
        end
    end
    table.sort(viableAllDiBombs,function (a,b) return a[1].value < b[1].value; end);
    return viableAllDiBombs;
end

--获得所有喜
function this.SuckAllXi(afterPresseDcards)
    if not afterPresseDcards then
        return nil;
    end
    local viableAllXi = {};
    local countTable = this.GetCardCountByType(afterPresseDcards,this.ByValue);
    for key, value in pairs(countTable) do
        if this.IsTongZiOrXi(value,this.JudgeByXi) then
            table.insert(viableAllXi,value);
        else
            -- 喜藏在炸弹里面
            local typeCountTable = this.GetCardCountByType(value,this.ByType);
            for typeKey, typeValue in pairs(typeCountTable) do
                if #typeValue == 4 then
                    table.insert(viableAllXi,typeValue);
                end
            end
        end
    end
    table.sort(viableAllXi,
            function (a,b)
                if a[1].value < b[1].value then
                    return true;
                elseif a[1].value == b[1].value then
                    return a[1].type < b[1].type;
                else
                    return false;
                end

            end);
    return viableAllXi;
end

function this.generateChoose(cardsData,category)
    local chooseItem = {};
    chooseItem.category = category;
    chooseItem.cardsData = {};
    for i = 1, #cardsData do
        table.insert(chooseItem.cardsData,cardsData[i]);
    end


    return chooseItem;
end

--为玩家获得可以大于对手的可选牌
--cardCount 几副牌
function this.GetViableChooseCards(competitorCards, category, cardCount, keyCardCount)
    print("GetAviableChooseCards was called");
    local aviableChooseCards = {};

    local main,slave = this.SeperateMainAndSlave(competitorCards,category,cardCount,keyCardCount);
    --print("main.length:"..#main);
    --print("category:"..category);

    if category == this.DAN then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableSingle(main[1]),category));
    elseif category == this.DUI then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViablePair(main),category));
    elseif category == this.SAN then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableTrible(main),category));
    elseif category == this.LIAN_DUI then
        if cardCount == 3 or cardCount == 5 then
            table.insert(aviableChooseCards,this.generateChoose(this.GetViableContinuesPairAll(main,2,false,true),category));
        else
            table.insert(aviableChooseCards,this.generateChoose(this.GetViableContinuesPairAll(main,2,true,true),category));
        end
    elseif category == this.FEI then
        if cardCount == 3 or cardCount == 5 then
            table.insert(aviableChooseCards,this.generateChoose(this.GetViablePlaneAll(main,false,true),category));
        else
            table.insert(aviableChooseCards,this.generateChoose(this.GetViablePlaneAll(main,true,true),category));
        end
        --炸弹可以压上面的牌 炸弹 < 筒子 < 地炸（喜） 3副牌只有地炸且地炸最大 4副牌只有喜且喜最大，
    elseif category == this.ZHA_DAN then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableBomb(main,cardCount),category));
        table.insert(aviableChooseCards,this.generateChoose(this.GetAllTongzi(),this.TONG));
        if cardCount == 3 then
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllDiBombs(),this.DI_ZHA));
        else
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllXi(),this.XI));
        end
    elseif category == this.TONG then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableTongzi(main,cardCount),category));
        if cardCount == 3 then
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllDiBombs(),this.DI_ZHA));
        else
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllXi(),this.XI));
        end
    elseif category == this.DI_ZHA then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableDiBombs(main),category));
    elseif category == this.XI then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableXi(main,cardCount),category));
    end

    --获得所有可以压的牌
    if category == this.DAN or category == this.DUI or category == this.SAN or category == this.LIAN_DUI or category == this.FEI then
        table.insert(aviableChooseCards,this.generateChoose(this.GetAllBombs(),this.ZHA_DAN));
        table.insert(aviableChooseCards,this.generateChoose(this.GetAllTongzi(),this.TONG));
        if cardCount == 3 then
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllDiBombs(),this.DI_ZHA));
        else
            table.insert(aviableChooseCards,this.generateChoose(this.GetAllXi(),this.XI));
        end
    end

    table.sort(aviableChooseCards,function (a,b) return TipOrder[a.category] < TipOrder[b.category]; end);

    return aviableChooseCards;
end

--获得所有可以出的牌
function this.GetViableAllChooseCards(cardCount)
    --print("GetAviableAllChooseCards was called");

    local aviableChooseCards = {};

    table.insert(aviableChooseCards,this.generateChoose(this.GetViableSingle(),this.DAN));
    if cardCount == 3 then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViablePair(),this.DUI));
    else
        table.insert(aviableChooseCards,this.generateChoose(this.GetViablePair(),this.DUI));
    end

    table.insert(aviableChooseCards,this.generateChoose(this.GetViableTrible(),this.SAN));

    if cardCount == 3 or cardCount == 5 then
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableContinuesPair(),this.LIAN_DUI));
        table.insert(aviableChooseCards,this.generateChoose(this.GetViablePlane(),this.FEI));
    else
        table.insert(aviableChooseCards,this.generateChoose(this.GetViableContinuesPair(),this.LIAN_DUI));
        table.insert(aviableChooseCards,this.generateChoose(this.GetViablePlane(),this.FEI));
    end

    --炸弹可以压上面的牌 炸弹 < 筒子 < 地炸（喜） 3副牌只有地炸且地炸最大 4副牌只有喜且喜最大，
    table.insert(aviableChooseCards,this.generateChoose(this.GetAllBombs(),this.ZHA_DAN));
    table.insert(aviableChooseCards,this.generateChoose(this.GetAllTongzi(),this.TONG));
    if cardCount == 3 then
        table.insert(aviableChooseCards,this.generateChoose(this.GetAllDiBombs(),this.DI_ZHA));
    else
        table.insert(aviableChooseCards,this.generateChoose(this.GetAllXi(),this.XI));
    end

    table.sort(aviableChooseCards,function (a,b) return TipOrder[a.category] < TipOrder[b.category] end);
    return aviableChooseCards;
end

function this.GenerateChooseCardsData(aviableChooseCards,isWithPlate,isInclude_2_or_Jocker)
    if not aviableChooseCards then
        return nil;
    end

    local chooseCardsData = {};

    for i = 1, #aviableChooseCards do

        for j = 1, #aviableChooseCards[i].cardsData do
            local chooseDataItem = {};
            chooseDataItem.cards = {};
            chooseDataItem.breakOP = -1;--如果出这个牌，会拆掉什么，比如会拆掉炸弹，会拆掉筒子
            chooseDataItem.category = aviableChooseCards[i].category;

            if aviableChooseCards[i].category == this.DAN then
                chooseDataItem.breakOP = -1
                table.insert(chooseDataItem.cards,aviableChooseCards[i].cardsData[j]);
            elseif aviableChooseCards[i].category == this.ZHA_DAN or--炸弹，筒子，地炸，喜 都是整体找出来的，没有从别的地方拆，所以不存在拆掉炸弹的情况
                    aviableChooseCards[i].category == this.TONG or
                    aviableChooseCards[i].category == this.DI_ZHA or
                    aviableChooseCards[i].category == this.XI
            then

                chooseDataItem.breakOP = -1
                for k = 1, #aviableChooseCards[i].cardsData[j] do
                    table.insert(chooseDataItem.cards,aviableChooseCards[i].cardsData[j][k]);
                end

            else

                chooseDataItem.breakOP = aviableChooseCards[i].cardsData[j].breakOP;
                for k = 1, #aviableChooseCards[i].cardsData[j].value do
                    table.insert(chooseDataItem.cards,aviableChooseCards[i].cardsData[j].value[k]);
                end

                --如果是三带的牌，需要插入三带的牌，前提是允许三带牌
                if aviableChooseCards[i].category == this.SAN then
                    local withCards = this.GetTribleWithPlates(isWithPlate,isInclude_2_or_Jocker);
                    for k = 1, #withCards do
                        table.insert(chooseDataItem.cards,withCards[k]);
                    end
                end

                --如果是飞机带牌
                if aviableChooseCards[i].category == this.FEI then
                    local withCards = this.GetPlaneWithPlates(isWithPlate,#aviableChooseCards[i].cardsData[j].value);
                    for k = 1, #withCards do
                        table.insert(chooseDataItem.cards,withCards[k]);
                    end
                end



            end
            table.insert(chooseCardsData,chooseDataItem);
        end

    end

    return chooseCardsData;

end


--获得三张需要带的牌,从单牌，对子中拆
function this.GetTribleWithPlates(isWithPlate,isInclude_2_or_Jocker)
    if not isWithPlate then
        return {};
    end

    local withCards = {};
    --1 手上有足够的单张可以带
    if #SingleDB>=2 then
        --2 手上没有足够的单牌【比如只有一张单牌，或者没有单牌】
        for i = 1, 2 do
            table.insert(withCards,SingleDB[i][1]);
        end

    else
        local needPairs = this.GetPairExceptContinusPair(isInclude_2_or_Jocker);
        table.sort(needPairs,function (a,b) return a[1].value < b[1].value; end);

        if #SingleDB == 1 then
            if #needPairs >= 1 then

                --2.1 手上只有一张单牌，并且单牌小于最小对子,带上单张，斌且从对子中拆一个牌
                if SingleDB[1][1].value < needPairs[1][1].value then
                    table.insert(withCards,SingleDB[1][1]);
                    table.insert(withCards,needPairs[1][1]);
                    --2.1 手上有一张单牌，并且单牌大于最小对子，则直接取最小的对子
                else
                    for i = 1, #needPairs[1] do
                        table.insert(withCards,needPairs[1][i]);
                    end
                end
            else
                table.insert(withCards,SingleDB[1][1]);
            end
        else
            --2.3 手上没有单牌，直接带最小对子
            if #needPairs >= 1 then
                for i = 1, #needPairs[1] do
                    table.insert(withCards,needPairs[1][i]);
                end
            --3 手上没有单牌也没有对子
            else

            end

        end
    end
    return withCards;
end


--获得不在连对中的对子
function this.GetPairExceptContinusPair(isInclude_2_or_Jocker)

    --拿出所有连对
    local allContinusPair = this.GetViableContinuesPair(nil,2,isInclude_2_or_Jocker,true);

    local needPairs = {};

    for i = 1, #PairDB do
        local find = false;
        for j = 1, #allContinusPair do
            if this.IsFindInTable(allContinusPair[j].value,PairDB[i][1],"db_id") or this.IsFindInTable(allContinusPair[j].value,PairDB[i][2],"db_id") then
                find = true;
                break;
            end
        end
        if not find then
            table.insert(needPairs,PairDB[i]);
        end

    end
    return needPairs;

end


--获得飞机需要带的牌
function this.GetPlaneWithPlates(isWithPlate,planeLength)

    if not isWithPlate then
        return {};
    end

    local withCards = {};
    local withCardLength = planeLength/3*2;
    --1.带不完或者刚好带完单牌
    if #SingleDB >= withCardLength then
        for i = 1, withCardLength do
            table.insert(withCards,SingleDB[i][1]);
        end
    --2.带完搜友的单牌还能继续带牌
    else

        --2.1 先把所有单牌放进去
        for i = 1, #SingleDB do
            table.insert(withCards,SingleDB[i][1]);
        end

        --2.2从对子中放进一些去
        for i = 1, #PairDB do
            for j = 1, #PairDB[i] do
                if #withCards < withCardLength then
                    table.insert(withCards,PairDB[i][j]);
                else
                    break;
                end
            end
        end

    end

    return withCards;

end


--是否可以通过飞机一次性打出所有的牌
function this.IsCanThrowAllByPlane(cards,cardCount,isNeedOffCut,category)
    local canThrowAll = true;
    local main,slave = this.SeperateMainAndSlave(cards,category,cardCount,category);
    local planes = this.GetViablePlaneAll(main,cardCount==4,isNeedOffCut);
    --获得最长的飞机
    table.sort(planes,function (a,b)  return #a > #b ;end);
    --print("#planes:"..#planes);
    if #planes > 0 then
        local longestPlane = planes[1];
        if (#longestPlane.value + #longestPlane.value/3*2) >= #CardsDB then
            return true;
        else
            return false;
        end
    else
        canThrowAll = false;
    end

    return canThrowAll;

end

--获得拆除的字符串
function  this.GetBreakString(breakOp)

    if not breakOp then return nil end;

    if breakOp == this.ZHA_DAN then
        return "拆掉炸弹";
    elseif breakOp  == this.TONG then
        return "拆掉筒子";
    elseif breakOp  == this.DI_ZHA then
        return "拆掉地炸";
    elseif breakOp  == this.XI then
        return "拆掉喜";
    elseif breakOp == this.SAN then
        return "拆掉三张";
    end

end


--通过选择的牌，判断拆除了哪些筒子，炸弹
function this.GetBreakData(selectCards,cardCount)

    local breakData     = {};

    --1.优先判断喜，地炸
    if cardCount == 3 then

        for i = 1, #selectCards do
            if not this.IsDiBomb(selectCards) then
                for key, value in pairs(DiBombDB) do
                    if this.IsFindInTable(value,selectCards[i],"db_id")  then
                        local breakItem = {};
                        breakItem.breakOP = this.DI_ZHA;
                        breakItem.value = value[1];
                        table.insert(breakData,breakItem);
                        return breakData;
                    end
                end
            end

        end
    else
        for i = 1, #selectCards do
            if not this.IsTongZiOrXi(selectCards,this.JudgeByXi) then
                for key, value in pairs(XiDB) do
                    if this.IsFindInTable(value,selectCards[i],"db_id") then
                        local breakItem = {};
                        breakItem.breakOP = this.XI;
                        breakItem.value = value[1];
                        table.insert(breakData,breakItem);
                        return breakData;
                    end
                end
            end
        end
    end
    --2.判断筒子
    for i = 1, #selectCards do

        if (not this.IsTongZiOrXi(selectCards,this.JudgeByTongzi)) and (not this.IsDiBomb(selectCards)) and (not this.IsTongZiOrXi(selectCards,this.JudgeByXi)) then
            for key, value in pairs(TongZiDB) do
                if this.IsFindInTable(value,selectCards[i],"db_id") then
                    local breakItem = {};
                    breakItem.breakOP = this.TONG;
                    breakItem.value = value[1];
                    table.insert(breakData,breakItem);
                    return breakData;
                end
            end
        end
    end
    --3.判断炸弹
    for i = 1, #selectCards do
        if (not this.IsTongZiOrXi(selectCards,this.JudgeByXi)) and
                (not this.IsTongZiOrXi(selectCards,this.JudgeByTongzi)) and
                (not this.IsDiBomb(selectCards))
        then

            for key, value in pairs(BombDB) do
                if this.IsFindInTable(value,selectCards[i],"db_id") then

                    --炸弹拆自己（比如 55555，你出5555），
                    if #selectCards ~= #value then
                        local breakItem = {};
                        breakItem.breakOP = this.ZHA_DAN;
                        breakItem.value = value[1];
                        table.insert(breakData,breakItem);
                        return breakData;
                    end

                end
            end

        end
    end
    return breakData;
end


--获得牌面值最大的单张
function this.GetMaxSingleValueData()
    if not SingleDB or #SingleDB == 0 then
        return -1;
    end
    return SingleDB[#SingleDB][1].value;
end

--获得牌面值最大的三张
function this.GetMaxTribleValueData()
    if not TribleDB or #TribleDB == 0 then
        return -1;
    end
    return TribleDB[#TribleDB][1].value;
end

--获得牌面值最大的对子
function this.GetMaxPairValueData()
    if not PairDB or #PairDB == 0 then
        return -1;
    end
    --print("GetMaxPairValueData:"..tostring(PairDB[#PairDB].value));
    return PairDB[#PairDB][1].value;
end



function this.SetSanOrder(isWithPlate)

    --可以三带牌的顺序
    if isWithPlate then
        TipOrder[this.DAN]      = 4;
        TipOrder[this.DUI]      = 3;
        TipOrder[this.SAN]      = 1;
        TipOrder[this.LIAN_DUI] = 2;
        TipOrder[this.FEI]      = 0;
        TipOrder[this.ZHA_DAN]  = 5;
        TipOrder[this.TONG]     = 6;
        TipOrder[this.DI_ZHA]   = 7;
        TipOrder[this.XI]       = 8;
    else
        TipOrder[this.DAN]      = 0;
        TipOrder[this.DUI]      = 2;
        TipOrder[this.SAN]      = 4;
        TipOrder[this.LIAN_DUI] = 1;
        TipOrder[this.FEI]      = 3;
        TipOrder[this.ZHA_DAN]  = 5;
        TipOrder[this.TONG]     = 6;
        TipOrder[this.DI_ZHA]   = 7;
        TipOrder[this.XI]       = 8;
    end
end






